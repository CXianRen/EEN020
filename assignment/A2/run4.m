clear
close all
clf
clc

addpath data
addpath code 

img_cube1 = imread("data/cube1.JPG");
img_cube2 = imread("data/cube2.JPG");

% load estimated camera P generated by run2.m
load estimated_p.mat
% load x1 and x2 generated by run3.m
load matched_points.mat

% compute X using point from x1 and x2 with P_1 and P_2 
X = [];
for i= 1: size(x1,2)
    X_i = triangulate_3D_point_DL(x1(:,i),x2(:,i),P_1_dN,P_2_dN);
    X = [X X_i];
end 

% projected points are red '+', SIIF-T poins are yellow 'o'
% P1
project_and_plot(P_1_dN,X,img_cube1)
hold on
plot(x1(1,:),x1(2,:), 'o', 'Color','y');
hold off
title("C4:x from estimated X in P1");
saveas(gcf,"c4_x_eX_P1.png");

%P2
project_and_plot(P_2_dN,X,img_cube2);
hold on
plot(x2(1,:),x2(2,:), 'o', 'Color','y');
hold off
title("C4:x from estimated X in P2");
saveas(gcf,"c4_x_eX_P2.png");

% normalizing x1 and x2 with K which is from rq.m
[K1 r1] = rq(P_1_dN);
[K2 r2] = rq(P_2_dN);

K1 = K1 ./ K1(3,3);
K2 = K2 ./ K2(3,3);

x1_n = inv(K1)* [x1; ones(1,size(x1,2))];
x2_n = inv(K2) * [x2;ones(1,size(x2,2))];
P_1_n = inv(K1) * P_1_dN;
P_2_n = inv(K2) * P_2_dN;

% compute X with normalized x and P
X_n = [];
for i= 1: size(x1,2)
    X_i = triangulate_3D_point_DL(x1_n(:,i),x2_n(:,i),P_1_n,P_2_n);
    X_n = [X_n X_i];
end 

% projected points (by normalized data) are red '+',
% SIIF-T poins are yellow 'o', 
% Notic !! when we project X back to image, we still used uncalibrated camera (or times by K)!
% P1
figure;
imshow(img_cube1)
x_p_1_n = P_1_dN * X_n;
x_p_1_n = x_p_1_n ./ x_p_1_n(3,:); % flatten
hold on
plot(x_p_1_n(1,:),x_p_1_n(2,:), '+', 'Color','r');
plot(x1(1,:),x1(2,:), 'o', 'Color','y');
hold off
title("C4:x from estimated X in normalized P1");
saveas(gcf,"c4_x_eX_P1_n.png");

% P2
figure;
imshow(img_cube2)
x_p_2_n = P_2_dN * X_n;
x_p_2_n = x_p_2_n ./ x_p_2_n(3,:); % flatten
hold on
plot(x_p_2_n(1,:),x_p_2_n(2,:), '+', 'Color','r');
plot(x2(1,:),x2(2,:), 'o', 'Color','y');
hold off
title("C4:x from estimated X in normalized P2");
saveas(gcf,"c4_x_eX_P2_n.png");

% select good points
good_points = (sqrt(sum((x1 - x_p_1_n(1:2,:)).^2))< 3 & ...
    sqrt(sum((x2 - x_p_2_n(1:2,:)).^2))< 3);

X = X(:, good_points);

% flatten X before plot it
X = X ./ X(4,:);

plot3(X(1,:),X(2,:),X(3,:),'.' ,'color', 'r');
hold on
plotcams({P_1_n,P_2_n});
load compEx3data.mat
plot3([Xmodel(1,startind); Xmodel(1,endind)], ...
      [Xmodel(2,startind); Xmodel(2,endind)], ...
      [Xmodel(3,startind); Xmodel(3,endind)], 'b-');
axis equal
hold off
